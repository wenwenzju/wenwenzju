time: 2015
category: 其他
name: matlab调用c++
ymd: 2015-11-01
hms: 11:26:00
description: matlab与c/c++混合编程——matlab调用c/c++
title: matlab与c/c++混合编程——matlab调用c/c++
main_page_description: 通过简单的例子说明如何使用matlab调用c/c++的函数接口。
main_page_add: true
main_page_pos: 2
20[description]: ${description}
22[og-title]: ${description}
23[og-url]: ${time}/${category}/${name}/index.html
25[og-description]: ${description}
26[og-updated_time]: ${ymd}T${hms}Z
58[title]: ${title}
273[article_id]: ${title}
276[article_href]: ./timeline/${time}/${category}/${name}/
277[article_datetime]: ${ymd}T${hms}Z
277[time_disp]: ${ymd}
285[article_title]: ${title}
291[article_category_href]: ${category}
291[article_category]: ${category}
305[copyright_title_href]: ${time}/${category}/${name}/
305[copyright_title]: ${title}
307[publish_time]: ${ymd}, ${hms}
308[update_time]: ${ymd}, ${hms}
369[bdText]: ${description}
385[data-thread-key]: ${time}/${category}/${name}/
385[data-title]: ${title}
385[data-url]: ${time}/${category}/${name}/
511[top]: ${time}/${category}/${name}/
512[comments]: ${time}/${category}/${name}/
513[bottom]: ${time}/${category}/${name}/
298[article_body]: <p><span></span>假设我们有一个用c++写的读图并显示的函数：void imread(const char* imgpath, cv::Mat&amp; img);这里用到了opencv的一些接口，那么怎样用matlab调用这个接口呢？要用到mex.h中定义的mexFunction函数，关于这个函数可以在matlab的help文档里学习。代码如下：</p>
<p></p>
<pre><code class="language-cpp">#include "opencv2/opencv.hpp"
#include "mex.h"

void imread(const char* imgpath, cv::Mat&amp; img)
{
	img = cv::imread(imgpath);
	cvNamedWindow("image", 0);
	cv::imshow("image", img);
    cv::waitKey(100);
}

void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] )
{
	if (nrhs &lt; 1)
	{
		mexErrMsgTxt("Not enough input arguments.\n");
	}
	else if (nrhs &gt; 1)
	{
		mexErrMsgTxt("Too many input arguments.\n");
	}
	char imgpath[100];
	int imgpathlen = mxGetNumberOfElements(prhs[0]);
	mxGetString(prhs[0], imgpath, imgpathlen+1);//why plus 1, see matlab help document

	cv::Mat img;
	imread(imgpath, img);
	mexPrintf("image size: %d, %d\n", img.cols, img.rows);
	if (nlhs == 0)
	{
		return;
	}
	int rows, cols, channels;
	rows = img.rows;
	cols = img.cols;
	channels = img.channels();

	mexPrintf("channels: %d\n", channels);
	if (channels == 1)
	{
		mwSize dims[2] = {rows, cols};
		plhs[0] = mxCreateNumericArray(2, dims, mxUINT8_CLASS, mxREAL);
		cv::Mat tmpimg = img.t();
		memcpy(mxGetPr(plhs[0]), tmpimg.data, rows*cols*mxGetElementSize(plhs[0]));
	}
	else if (channels == 3)
	{
		mwSize dims[3] = {rows, cols, 3};
		plhs[0] = mxCreateNumericArray(3, dims, mxUINT8_CLASS, mxREAL);
		std::vector&lt;cv::Mat&gt; ch;
		split(img, ch);
		cv::Mat R = ch[2].t();
		int bitdepth = sizeof(uchar);
		memcpy((uchar*)mxGetData(plhs[0]), R.data, rows*cols*bitdepth);
		//mxGetPr返回值为double*,此处应为mxGetData,返回值为void*,须进行强制转换
		cv::Mat G = ch[1].t();
		memcpy((uchar*)mxGetData(plhs[0])+rows*cols*bitdepth, G.data, rows*cols*bitdepth);
		cv::Mat B = ch[0].t();
		memcpy((uchar*)mxGetData(plhs[0])+rows*cols*bitdepth*2, B.data, rows*cols*bitdepth);
		//opencv的Mat是按行存储，且顺序为BGR，即先存第一行：(B,G,R),(B,G,R)...
		//matlab的Mat是按列存储，且先存完R,再存G,再存B，即第一列：R;R;R...G;G;G...B;B;B...
	}
}</code></pre><br /><span></span>上述代码保存为imread.cpp文件，有了此代码，打开matlab，当前工作目录切换到imread.cpp所在的目录，matlab命令窗口中输入
<p></p>
<p></p>
<pre><code class="language-plain"> mex -IE:\opencv\build\include -LE:\opencv\build\x86\vc10\lib -lopencv_core248 -lopencv_highgui248  imread.cpp</code></pre><br /><span></span>关于mex的具体用法，可参见help，-I指定第三方头文件目录，-L指定第三方lib文件目录，-l指定lib文件目录下所依赖的具体lib，注意此处不能用opencv的debug库，最后是要编译的cpp文件。还有一种方法是采用mexopts.bat文件，在C:\Users\New\AppData\Roaming\MathWorks\MATLAB\R2010b\mexopts.bat下，可通过在并令窗口中输入fullfile(prefdir,'mexopts.bat')获得该文件的路径，一般不要在原文件中修改，而是把它考出来放到imread.cpp目录下，在其中添加依赖的第三方头文件和库目录，最后用mex
 -f mexopts.bat imread.cpp编译即可。
<p></p>
<p><span></span>编译通过会生成一个imread.mexw32的文件，有了它，接口就生成了。命令窗口输入img=imread(path of image);即能成功显示图像并将图像数据存储在img中。</p>